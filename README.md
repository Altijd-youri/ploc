# PLOC - PL/SQL code to doc converter

PLOC is a simple PL/SQL to doc converter which generates Markdown output. Simple means here really simple - the converter is only about 150 lines of commented JavaScript code. Here a short demo package spec which demonstrates the idea behind PLOC:

~~~sql
CREATE OR REPLACE PACKAGE DEMO AUTHID current_user IS
c_demo_name CONSTANT VARCHAR2(30 CHAR) := 'A demo package for PLOC';
/**
PL/SQL Demo Package

You can use standard markdown here to describe your package, functions and procedures.

- This is a list entry
- A second one

[A link](https://daringfireball.net/projects/markdown/basics).
**/


FUNCTION to_zip (
  p_file_collection IN apex_t_export_files -- The file collection to process with APEX_ZIP.
) RETURN BLOB;
/**
Convert a file collection to a zip file.

EXAMPLE

```sql
DECLARE
  l_zip BLOB;
BEGIN
    l_zip := plex.to_zip(plex.backapp(
      p_app_id             => 100,
      p_include_object_ddl => true
    ));

  -- do something with the zip file...
END;
```
**/
~~~

- The converter picks up everything between the keywords package, function, procedure, type or trigger and a following PL/SQL multiline comment starting with `/**` and ending with `**/` (the double stars are used to support normal multiline comments, which are not picked up)
- Anything else is ignored - if you want to include something in your docs, you have to provide a comment in the mentioned style after the relevant signature
- In the comments you can provide standard Markdown - anything what the target system (GitHub for example) can convert to valid HTML (we do not generate the HTML here, only the Markdown file)
- In the example above the constant `c_demo_name` is included in the docs - if you don't want this move the code behind the comment - you decide which globals are documented and which not
- There is no parameter parsing: the converter prints for each found item the following informations
  - A header (`# Package DEMO` or `## FUNCTION to_zip` in our example)
  - The comment
  - A paragraph containing the word `SIGNATURE`
  - Wrapped in a code block the Signature of the package, function, procedure...
  - Depending on the number of items (configurable) a TOC is generated in front of the document

Many words... Here the converted output of our example package:

~~~md
# PACKAGE DEMO

PL/SQL Demo Package

You can use standard markdown here to describe your package, functions and procedures.

- This is a list entry
- A second one

[A link](https://daringfireball.net/projects/markdown/basics).

SIGNATURE

```sql
CREATE OR REPLACE PACKAGE DEMO AUTHID current_user IS
c_demo_name CONSTANT VARCHAR2(30 CHAR) := 'A demo package for PLOC';
```

## FUNCTION to_zip

Convert a file collection to a zip file.

EXAMPLE

```sql
DECLARE
  l_zip BLOB;
BEGIN
    l_zip := plex.to_zip(plex.backapp(
      p_app_id             => 100,
      p_include_object_ddl => true
    ));

  -- do something with the zip file...
END;
```

SIGNATURE

```sql
FUNCTION to_zip (
  p_file_collection IN apex_t_export_files -- The file collection to process with APEX_ZIP.
) RETURN BLOB;
```
~~~

For a bigger example simply see the [PLEX project](https://github.com/ogobrecht/plex), which uses PLOC for the generation of the project README.md file:

- [The package source code](https://github.com/ogobrecht/plex/blob/master/PLEX.pks)
- [The README file rendered as HTML by GitHub](https://github.com/ogobrecht/plex)
- [The raw Markdown file generated by PLOC](https://raw.githubusercontent.com/ogobrecht/plex/master/README.md)

## FAQ's

QUESTION: Why no Javadoc compatible parameter desriptions?

ANSWER: In my opinion this does NOT follow the DRY principle. PL/SQL is a strong typed language. Anything you need to know is visible in the signature. There is no need to repeat the parameter in a formal way only to comment it a little bit. For short comments you can put a single line comment direct after the parameter (see parameter `p_file_collection` in function `to_zip` in the example above). If you need to write more refer to the Markdown description. On long parameter list you will more easy follow the single line comments direct after the parameters then looking around between the signature and the formal Javadoc description.

QUESTION: Why do I need to put the comments below the signature?

ANSWER: If we put the comments before the signature the PL/SQL compiler will strip out the comment - at least for the comment of the package itself or a standalone function, procedure or trigger. If you then get the DDL of your objects out of the database with dbms_metadata you will lose these first comments. This will be no problem if you follow the files first approach together with a version control system but who knows in what ways your code will be inspected? It would be nice for the reviewers to get all provided comments.


## Installation

In your repo install ploc:

```js
npm install ploc
```


## Example - Single File

Create a npm script file, for example `scripts/build_docs.js`:

```js
var ploc = require('ploc');
var inFilePattern  = process.argv[2]; // first command line parameter, defaults to "**/*.pks"
var outFilePattern = process.argv[3]; // second one, defaults to "{folder}{file}.md"
var minItemsForToc = process.argv[4]; // third one, defaults to 5

ploc.files2docs(inFilePattern, outFilePattern, minItemsForToc)
```

Add a new npm script entry in your package.json - here an example from my PLEX project - we call it `build:docs`:

```js
{
  "name": "plex",
  "scripts": {
    "build:docs": "node scripts/build_docs.js PLEX.pks README.md",
  },
  "dependencies": {
    "ploc": "^0.3.0"
  }
}
```

Note that we use only two of our possible three parameters: inFilePattern and outFilePattern.

Running the script:

```sh
npm run build:docs
```

The output will be something like this:

```sh
> plex@ build:docs /Users/ottmar/code/plex
> node scripts/build_docs.js PLEX.pks README.md

PLEX.pks => README.md
```

For each generated Markdown document you get one line of log entry with the input and output file - here we have only one line `PLEX.pks => README.md`


## Example - Multiple Files

We add now a script called `build:all_docs`:

```js
{
  "name": "plex",
  "scripts": {
    "build:docs": "node scripts/build_docs.js PLEX.pks README.md",
    "build:all_docs": "node scripts/build_docs.js",
  },
  "dependencies": {
    "ploc": "^0.3.0"
  }
}
```

As you can see we omit simply all parameters and therefore the defaults are used (inFilePattern = `**/*.pks`, 
outFilePattern = `{folder}{file}.md`), which results in converting all found *.pks files in all directories and subdirectories. Here the output of this conversion:

```sh
> plex@ build:all_docs /Users/ottmar/code/plex
> node scripts/build_docs.js

PLEX.pks => PLEX.md
temp/source/test_1.pks => temp/source/test_1.md
temp/source/test_2.pks => temp/source/test_2.md
```

Obviously I have some test files in the source folder. You can also see on this example that you can use the variables `{folder}` (directory path of source file with trailing directory separator) and `{file}` (source file name without extension) in your second outFilePattern. The first inFilePattern is a standard [glob file pattern](https://github.com/isaacs/node-glob#glob).

One common use case is to place all docs in a docs folder - we change therefore our `build:all_docs` script:

```js
{
  "name": "plex",
  "scripts": {
    "build:docs": "node scripts/build_docs.js PLEX.pks README.md",
    "build:all_docs": "node scripts/build_docs.js **/*.pks docs/{file}.md",
  },
  "dependencies": {
    "ploc": "^0.3.0"
  }
}
```

Note that the target directory `docs` must already exist - otherwise Node.js will throw an error. The resulting Output should something like this:

```sh
> plex@ build:all_docs /Users/ottmar/code/plex
> node scripts/build_docs.js **/*.pks docs/{file}.md

PLEX.pks => docs/PLEX.md
temp/source/test_1.pks => docs/test_1.md
temp/source/test_2.pks => docs/test_2.md
```


## Automation with file watcher

We use here [chokidar](https://www.npmjs.com/package/chokidar-cli) - you can install it with `npm install chokidar-cli`. Then we create a watch script entry - here it is named `watch:docs`.

```js
{
  "name": "plex",
  "scripts": {
    "build:docs": "node scripts/build_docs.js PLEX.pks README.md",
    "watch:docs": "chokidar PLEX.pks package.json --initial -c \"npm run build:docs\""
  },
  "dependencies": {
    "chokidar-cli": "^1.2.0",
    "ploc": "^0.3.0"
  }
}
```

Notes:

- `chokidar PLEX.pks package.json` the files to watch (or glob patterns) are listed with a whitspace character as a separator
- `-- initial` tells the watcher to run the script on start
- `-c \"npm run build:docs\""` is the command to run when one of the watched files changes - the escaped double quotes are important for windows

To start the watcher you run this:

```sh
npm run watch:docs
```

Here the output after the start:

```sh
> plex@ watch:docs /Users/ottmar/code/plex
> chokidar PLEX.pks package.json --initial -c "npm run build:docs"

add:PLEX.pks
add:package.json
Watching "PLEX.pks", "package.json" ..

> plex@ build:docs /Users/ottmar/code/plex
> node scripts/build_docs.js PLEX.pks README.md

PLEX.pks => README.md
```

The terminal is blocked because of the running watcher - after a file change you will see something like this:

```sh
change:PLEX.pks

> plex@ build:docs /Users/ottmar/code/plex
> node scripts/build_docs.js PLEX.pks README.md

PLEX.pks => README.md
```


## Read more about npm scripts

- https://medium.freecodecamp.org/introduction-to-npm-scripts-1dbb2ae01633
- https://medium.freecodecamp.org/why-i-left-gulp-and-grunt-for-npm-scripts-3d6853dd22b8
- https://css-tricks.com/why-npm-scripts/

